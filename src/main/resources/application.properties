# --------------------------------------------
# Data Source
# --------------------------------------------
# Change the port to whatever port you're using
spring.datasource.url=${RDS_DATASOURCE}
# Change this to your SQL username:
spring.datasource.username=${RDS_DATASOURCE_USERNAME}
# Change this to your SQL password:
spring.datasource.password=${RDS_DATASOURCE_PASSWORD}
# spring.datasource.driver-class-name=com.mysql.jdbc.Driver

# --------------------------------------------
# JPA
# --------------------------------------------
spring.jpa.database-platform = org.hibernate.dialect.MySQL5InnoDBDialect
spring.jpa.generate-ddl=true
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true

# Uses the naming strategy for JPA 1.0
# So it doesn't add the underscore when creating the table
# The current naming strategy converts camelCase to snake_case
# spring.jpa.hibernate.naming.implicit-strategy=org.hibernate.boot.model.naming.ImplicitNamingStrategyLegacyJpaImpl
# spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl

jwt.secret=javawarriors

server.port=5000

spring.servlet.multipart.max-file-size=50MB

# AWS S3 configuration
aws_access_key_id=${AWS_ACCESS_KEY_ID}
aws_secret_access_key=${AWS_SECRET_ACCESS_KEY}
aws_session_token=${AWS_SESSION_TOKEN}
aws.s3.bucket=${S3_IMAGE_BUCKET}
aws.s3.region=us-east-1
aws.personalize.wtb.campaign_arn_user=${PERSONALIZE_WTB_CAMPAIGN_ARN_USER}
aws.personalize.wtb.campaign_arn_item=
aws.personalize.ifs.campaign_arn_user=${PERSONALIZE_IFS_CAMPAIGN_ARN_USER}
aws.personalize.wtb.filter_arn_user=${PERSONALIZE_WTB_FILTER_ARN_USER}
aws.personalize.ifs.filter_arn_user=${PERSONALIZE_IFS_FILTER_ARN_USER}

react_origin=${REACT_ORIGIN}